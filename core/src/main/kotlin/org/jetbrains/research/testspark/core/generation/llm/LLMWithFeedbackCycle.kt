package org.jetbrains.research.testspark.core.generation.llm

import io.github.oshai.kotlinlogging.KotlinLogging
import org.jetbrains.research.testspark.core.data.Report
import org.jetbrains.research.testspark.core.data.TestCase
import org.jetbrains.research.testspark.core.error.LlmError
import org.jetbrains.research.testspark.core.error.TestSparkError
import org.jetbrains.research.testspark.core.error.TestSparkResult
import org.jetbrains.research.testspark.core.generation.llm.network.RequestManager
import org.jetbrains.research.testspark.core.generation.llm.prompt.PromptSizeReductionStrategy
import org.jetbrains.research.testspark.core.monitor.DefaultErrorMonitor
import org.jetbrains.research.testspark.core.monitor.ErrorMonitor
import org.jetbrains.research.testspark.core.progress.CustomProgressIndicator
import org.jetbrains.research.testspark.core.test.SupportedLanguage
import org.jetbrains.research.testspark.core.test.TestCompiler
import org.jetbrains.research.testspark.core.test.TestsAssembler
import org.jetbrains.research.testspark.core.test.TestsPersistentStorage
import org.jetbrains.research.testspark.core.test.TestsPresenter
import org.jetbrains.research.testspark.core.test.data.TestCaseGeneratedByLLM
import org.jetbrains.research.testspark.core.test.data.TestSuiteGeneratedByLLM
import java.io.File

/**
 * Represents a response (result) of a feedback cycle.
 *
 * @param executionResult The result of executing the feedback cycle.
 * @param generatedTestSuite The test suite generated by LLM.
 * @param compilableTestCases The set of compilable test cases generated by LLM.
 *
 * @throws IllegalArgumentException if `executionResult` is [FeedbackCycleExecutionResult.OK] and `generatedTestSuite` is null.
 */
data class FeedbackResponse(
    val generatedTestSuite: TestSuiteGeneratedByLLM,
    val compilableTestCases: MutableSet<TestCaseGeneratedByLLM>,
)

/**
 * LLMWithFeedbackCycle class represents a feedback cycle for an LLM.
 *
 * @property report The `Report` instance used for storing generated tests.
 * @property language The `SupportedLanguage` enum value representing the programming language used.
 * @property initialPromptMessage The initial prompt message to start the feedback cycle.
 * @property promptSizeReductionStrategy The `PromptSizeReductionStrategy` instance used for reducing the prompt size.
 * @property testSuiteFilename The name of the file in which the test suite is saved in the result path.
 * @property packageName The package name for the generated tests.
 * @property resultPath The temporary path where all the generated tests and their Jacoco report are saved.
 * @property buildPath All the directories where the compiled code of the project under test is saved.
 * @property requestManager The `RequestManager` instance used for making LLM requests.
 * @property testsAssembler The `TestsAssembler` instance used for assembling generated tests.
 * @property testCompiler The `TestCompiler` instance used for compiling tests.
 * @property testStorage The `TestsPersistentStorage` instance used for storing generated tests.
 * @property testsPresenter The `TestsPresenter` instance used for presenting generated tests.
 * @property indicator The `CustomProgressIndicator` instance used for tracking progress.
 * @property requestsCountThreshold The threshold for the maximum number of requests in the feedback cycle.
 * @property errorMonitor The `ErrorMonitor` instance used for monitoring errors.
 */
class LLMWithFeedbackCycle(
    private val report: Report,
    private val language: SupportedLanguage,
    private val initialPromptMessage: String,
    private val promptSizeReductionStrategy: PromptSizeReductionStrategy,
    // filename in which the test suite is saved in the result path
    private val testSuiteFilename: String,
    private val packageName: String,
    // temp path where all the generated tests and their jacoco report are saved
    private val resultPath: String,
    // all the directories where the compiled code of the project under test is saved. This path will be used as a classpath to run each test case
    private val buildPath: String,
    private val requestManager: RequestManager,
    private val testsAssembler: TestsAssembler,
    private val testCompiler: TestCompiler,
    private val testStorage: TestsPersistentStorage,
    private val testsPresenter: TestsPresenter,
    private val indicator: CustomProgressIndicator,
    private val requestsCountThreshold: Int,
    private val errorMonitor: ErrorMonitor = DefaultErrorMonitor(),
) {
    enum class WarningType {
        TEST_SUITE_PARSING_FAILED,
        NO_TEST_CASES_GENERATED,
        COMPILATION_ERROR_OCCURRED,
    }

    private val log = KotlinLogging.logger { this::class.java }

    fun run(onWarningCallback: ((WarningType) -> Unit)? = null): TestSparkResult<FeedbackResponse, TestSparkError> {
        var requestsCount = 0
        var generatedTestsArePassing = false
        var nextPromptMessage = initialPromptMessage

        val compilableTestCases: MutableSet<TestCaseGeneratedByLLM> = mutableSetOf()

        // collect imports from all responses
        val imports: MutableSet<String> = mutableSetOf()

        var generatedTestSuite: TestSuiteGeneratedByLLM? = null

        while (!generatedTestsArePassing) {
            requestsCount++

            log.info { "Iteration #$requestsCount of feedback cycle" }

            // Process stopped checking
            if (indicator.isCanceled()) {
                return TestSparkResult.Failure(error = LlmError.FeedbackCycleCancelled())
                break
            }

            if (isLastIteration(requestsCount) && compilableTestCases.isEmpty()) {
                // record a report with parsable yet potentially
                // non-compilable test cases stored in
                // the generated test suite
                // TODO: ensure generatedTestSuite is always non-null here
                generatedTestSuite?.let { recordReport(report, it.testCases) }
                break
            }

            // clearing test assembler's collected text on the previous attempts
            testsAssembler.clear()
            val response: TestSparkResult<TestSuiteGeneratedByLLM, TestSparkError> = requestManager.request(
                language = language,
                prompt = nextPromptMessage,
                indicator = indicator,
                packageName = packageName,
                testsAssembler = testsAssembler,
                isUserFeedback = false,
                errorMonitor,
            )

            // Process stopped checking
            if (indicator.isCanceled()) {
                return TestSparkResult.Failure(error = LlmError.FeedbackCycleCancelled())
                break
            }

            when (response) {
                is TestSparkResult.Success -> {
                    log.info { "Test suite generated successfully: ${response.data!!}" }
                    // check that there are some test cases generated
                    if (response.data!!.testCases.isEmpty()) {
                        onWarningCallback?.invoke(WarningType.NO_TEST_CASES_GENERATED)

                        nextPromptMessage =
                            "You have provided an empty answer! Please answer my previous question with the same formats."
                        continue
                    }
                }

                is TestSparkResult.Failure -> {
                    when (response.error) {
                        is LlmError.EmptyLlmResponse -> {
                            nextPromptMessage =
                                "You have provided an empty answer! Please, answer my previous question with the same formats"
                            continue
                        }

                        is LlmError.PromptTooLong -> {
                            if (promptSizeReductionStrategy.isReductionPossible()) {
                                nextPromptMessage = promptSizeReductionStrategy.reduceSizeAndGeneratePrompt()
                                /**
                                 * The current attempt does not count as a failure
                                 * since it was rejected due to the prompt size
                                 * exceeding the threshold
                                 */
                                requestsCount--
                                continue
                            } else {
                                return TestSparkResult.Failure(error = LlmError.PromptTooLong())
                            }
                        }

                        is LlmError.TestSuiteParsingError -> {
                            onWarningCallback?.invoke(WarningType.TEST_SUITE_PARSING_FAILED)
                            log.info { "Cannot parse a test suite from the LLM response. LLM response: '$response'" }

                            nextPromptMessage = "The provided code is not parsable. Please, generate the correct code"
                            continue
                        }
                    }
                    continue
                }
            }

            generatedTestSuite = response.data

            // update imports list
            imports.addAll(generatedTestSuite.imports)

            // Process stopped checking
            if (indicator.isCanceled()) {
                return TestSparkResult.Failure(error = LlmError.FeedbackCycleCancelled())
            }

            // Save the generated TestSuite into a temp file
            val generatedTestCasesPaths: MutableList<String> = mutableListOf()

            if (isLastIteration(requestsCount)) {
                generatedTestSuite.updateTestCases(compilableTestCases.toMutableList())
            } else {
                for (testCaseIndex in generatedTestSuite.testCases.indices) {
                    val testCaseFilename = when (language) {
                        SupportedLanguage.Java -> "${getClassWithTestCaseName(generatedTestSuite.testCases[testCaseIndex].name)}.java"
                        SupportedLanguage.Kotlin -> "${getClassWithTestCaseName(generatedTestSuite.testCases[testCaseIndex].name)}.kt"
                    }

                    val testCaseRepresentation = testsPresenter.representTestCase(generatedTestSuite, testCaseIndex)

                    val saveFilepath = testStorage.saveGeneratedTest(
                        generatedTestSuite.packageName,
                        testCaseRepresentation,
                        resultPath,
                        testCaseFilename,
                    )

                    generatedTestCasesPaths.add(saveFilepath)
                }
            }

            val generatedTestSuitePath: String = testStorage.saveGeneratedTest(
                generatedTestSuite.packageName,
                testsPresenter.representTestSuite(generatedTestSuite),
                resultPath,
                testSuiteFilename,
            )

            // check that the file creation was successful
            var allFilesCreated = true
            for (path in generatedTestCasesPaths) {
                allFilesCreated = allFilesCreated && File(path).exists()
            }
            if (!(allFilesCreated && File(generatedTestSuitePath).exists())) {
                // either some test case file or the test suite file was not created
                return TestSparkResult.Failure(error = LlmError.FailedToSaveTestFiles())
            }

            // Get test cases
            val testCases: MutableList<TestCaseGeneratedByLLM> =
                if (!isLastIteration(requestsCount)) {
                    generatedTestSuite.testCases
                } else {
                    compilableTestCases.toMutableList()
                }

            // Compile the test file
            indicator.setText("Compilation tests checking")

            val testCasesCompilationResult =
                testCompiler.compileTestCases(generatedTestCasesPaths, buildPath, testCases, resultPath)
            val testSuiteCompilationResult =
                testCompiler.compileCode(File(generatedTestSuitePath).absolutePath, buildPath, resultPath)

            // saving the compilable test cases
            compilableTestCases.addAll(testCasesCompilationResult.compilableTestCases)

            // Process stopped checking
            if (indicator.isCanceled()) {
                return TestSparkResult.Failure(error = LlmError.FeedbackCycleCancelled())
            }

            if (!testCasesCompilationResult.allTestCasesCompilable && !isLastIteration(requestsCount)) {
                log.info { "Non-compilable test suite: \n${testsPresenter.representTestSuite(generatedTestSuite!!)}" }

                onWarningCallback?.invoke(WarningType.COMPILATION_ERROR_OCCURRED)

                nextPromptMessage = """
                   I cannot compile the tests that you provided. The error is:
                   ```
                   ${testSuiteCompilationResult.executionMessage}
                   ```
                   Fix this issue in the provided tests.\nGenerate public classes and public methods. Response only a code with tests between ```, do not provide any other text.
                """.trimIndent()
                log.info { nextPromptMessage }
                continue
            }

            log.info { "Result is compilable" }

            generatedTestSuite.imports.addAll(imports)

            generatedTestsArePassing = true

            recordReport(report, testCases)
        }

        return TestSparkResult.Success(
            data = FeedbackResponse(
                generatedTestSuite = generatedTestSuite!!,
                compilableTestCases = compilableTestCases,
            )
        )
    }

    /**
     * Records the generated test cases in the given report.
     *
     * @param report The report object to store the test cases in.
     * @param testCases The list of test cases generated by LLM.
     */
    private fun recordReport(report: Report, testCases: MutableList<TestCaseGeneratedByLLM>) {
        for ((index, test) in testCases.withIndex()) {
            report.testCaseList[index] = TestCase(index, test.name, test.toString(), setOf())
        }
    }

    private fun isLastIteration(requestsCount: Int): Boolean = requestsCount > requestsCountThreshold
}
