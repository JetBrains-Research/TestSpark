package org.jetbrains.research.testspark.tools.llm.generation

import com.gitlab.mvysny.konsumexml.konsumeXml
import com.intellij.execution.configurations.GeneralCommandLine
import com.intellij.execution.process.ScriptRunnerUtil
import com.intellij.openapi.components.service
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.module.Module
import com.intellij.openapi.progress.ProgressIndicator
import com.intellij.openapi.project.Project
import com.intellij.openapi.roots.CompilerModuleExtension
import com.intellij.openapi.roots.ModuleRootManager
import com.intellij.openapi.roots.ProjectRootManager
import org.jetbrains.research.testspark.TestSparkBundle
import org.jetbrains.research.testspark.data.Report
import org.jetbrains.research.testspark.data.TestCase
import org.jetbrains.research.testspark.editor.Workspace
import org.jetbrains.research.testspark.services.TestsExecutionResultService
import org.jetbrains.research.testspark.tools.llm.error.LLMErrorManager
import org.jetbrains.research.testspark.tools.llm.test.TestCaseGeneratedByLLM
import java.io.File

/**
 * The TestCoverageCollector class is responsible for collecting test coverage data and generating a report.
 *
 * @property indicator The progress indicator to display the current task progress.
 * @property project The project associated with the test generation.
 * @property classFQN The class under test's full qualified name.
 * @property resultPath The path to save the generated test coverage report.
 * @property generatedTestPaths The paths of the generated test files.
 * @property generatedTestFile The generated test file.
 * @property generatedTestPackage The package of the generated test file.
 * @property projectBuildPath The path to the project build directory.
 * @property testCases The list of test cases generated by the LLM.
 * @property fileNameFQN The fully qualified name of the file containing the class under test.
 */
class TestCoverageCollector(
    private val indicator: ProgressIndicator,
    private val project: Project,
    private val classFQN: String,
    private val resultPath: String,
    private val generatedTestPaths: List<String>,
    private val generatedTestFile: File,
    private val generatedTestPackage: String,
    private val projectBuildPath: String,
    private val testCases: MutableList<TestCaseGeneratedByLLM>,
    private val cutModule: Module,
    private val fileNameFQN: String,
) {
    private val log = Logger.getInstance(this::class.java)

    private val sep = File.separatorChar
    private val javaHomeDirectory = ProjectRootManager.getInstance(project).projectSdk!!.homeDirectory!!

    // source path
    private val sourceRoots = ModuleRootManager.getInstance(cutModule).getSourceRoots(false)
    private val report = Report()

    // list of covered lines during the exceptions
    private val linesCoveredDuringTheException = HashMap<String, Set<Int>>()

    /**
     * Executes Jacoco on the compiled test file and collects the Jacoco results.
     *
     * @return The normalized Jacoco report.
     */
    fun collect(): Report {
        log.info("Test collection begins")

        // run Jacoco on the compiled test file
        runJacoco()

        // collect the Jacoco results and return the report
        return report.normalized()
    }

    /**
     * Compiles the generated test file using the proper javac and returns a Pair
     * indicating whether the compilation was successful and any error message encountered during compilation.
     *
     * @return A Pair containing a boolean indicating whether the compilation was successful
     *         and a String containing any error message encountered during compilation.
     */
    private fun compileTestCases() {
        indicator.text = TestSparkBundle.message("compilationTestsChecking")

        // find the proper javac
        val javaCompile = File(javaHomeDirectory.path).walk().filter { it.name.equals("javac") && it.isFile }.first()

        for (index in generatedTestPaths.indices) {
            // compile file
            runCommandLine(
                arrayListOf(
                    javaCompile.absolutePath,
                    "-cp",
                    getPath(projectBuildPath),
                    generatedTestPaths[index],
                ),
            )

            // create .class file path
            val classFilePath = generatedTestPaths[index].replace(".java", ".class")

            // check is .class file exists
            if (File(classFilePath).exists()) {
                project.service<Workspace>().testGenerationData.compilableTestCases.add(testCases[index])
            }
        }
    }

    /**
     * Compiles the generated test file using the proper javac and returns a Pair
     * indicating whether the compilation was successful and any error message encountered during compilation.
     *
     * @return A Pair containing a boolean indicating whether the compilation was successful
     *         and a String containing any error message encountered during compilation.
     */
    fun compile(): Pair<Boolean, String> {
        indicator.text = TestSparkBundle.message("compilationTestsChecking")

        // compile test cases for extracting correct ones
        compileTestCases()

        // find the proper javac
        val javaCompile = File(javaHomeDirectory.path).walk().filter { it.name.equals("javac") && it.isFile }.first()
        // compile file
        val errorMsg = runCommandLine(
            arrayListOf(
                javaCompile.absolutePath,
                "-cp",
                getPath(projectBuildPath),
                generatedTestFile.absolutePath,
            ),
        )

        // create .class file path
        val classFilePath = generatedTestFile.absolutePath.replace(".java", ".class")

        // check is .class file exists
        return Pair(File(classFilePath).exists(), errorMsg)
    }

    /**
     * Runs Jacoco to collect code coverage data and generate reports.
     */
    private fun runJacoco() {
        indicator.text = TestSparkBundle.message("runningJacoco")

        log.info("Running jacoco")

        val className = generatedTestFile.name.split('.')[0]
        // find the proper javac
        val javaRunner = File(javaHomeDirectory.path).walk().filter { it.name.equals("java") && it.isFile }.first()
        // JaCoCo libs
        val jacocoAgentDir = getLibrary("jacocoagent.jar")
        val jacocoCLIDir = getLibrary("jacococli.jar")

        // Execute each test method separately
        for (testCase in testCases) {
            // name of .exec and .xml files
            val dataFileName = "${generatedTestFile.parentFile.absolutePath}/jacoco-${testCase.name}"

            // run the test method with jacoco agent
            val testExecutionError = runCommandLine(
                arrayListOf(
                    javaRunner.absolutePath,
                    "-javaagent:$jacocoAgentDir=destfile=$dataFileName.exec,append=false,includes=$classFQN",
                    "-cp",
                    "${getPath(projectBuildPath)}${getLibrary("JUnitRunner.jar")}:$resultPath",
                    "org.jetbrains.research.SingleJUnitTestRunner",
                    "$generatedTestPackage$className#${testCase.name}",
                ),
            )

            // add passing test
            if (testExecutionError.isEmpty()) project.service<TestsExecutionResultService>().addPassingTest(testCase.name)

            // collect lines covered during the exception
            linesCoveredDuringTheException[testCase.name] = collectLinesCoveredDuringException(testExecutionError)

            // Prepare the command for generating the Jacoco report
            val command = mutableListOf(
                javaRunner.absolutePath,
                "-jar",
                jacocoCLIDir,
                "report",
                "$dataFileName.exec",
            )

            // for classpath containing cut
            command.add("--classfiles")
            command.add(CompilerModuleExtension.getInstance(cutModule)?.compilerOutputPath!!.path)

            // for each source folder
            sourceRoots.forEach { root ->
                command.add("--sourcefiles")
                command.add(root.path)
            }

            // generate XML report
            command.add("--xml")
            command.add("$dataFileName.xml")

            log.info("Runs command: ${command.joinToString(" ")}")

            val reportGenerationError = runCommandLine(command as ArrayList<String>)

            // check if XML report is produced
            if (!File("$dataFileName.xml").exists()) {
                LLMErrorManager().errorProcess("Something went wrong with generating Jacoco report.", project)
                return
            }
            log.info("xml file exists")

            // save data to TestGenerationResult
            saveData(testCase, "$dataFileName.xml")
        }
    }

    /**
     * Collect lines covered during the exception happening.
     *
     * @param testExecutionError error output (including the thrown stack trace) during the test execution.
     * @return a set of lines that are covered in CUT during the exception happening.
     */
    private fun collectLinesCoveredDuringException(testExecutionError: String): Set<Int> {
        if (testExecutionError.isBlank()) {
            return emptySet()
        }

        val result = mutableSetOf<Int>()

        // get frames
        val frames = testExecutionError.split("\n\tat ").toMutableList()
        frames.removeFirst()

        frames.forEach { frame ->
            if (frame.contains(classFQN)) {
                val coveredLineNumber = frame.split(":")[1].replace(")", "").toIntOrNull()
                if (coveredLineNumber != null) {
                    result.add(coveredLineNumber)
                }
            }
        }

        return result
    }

    /**
     * Saves data of a given test case to a report.
     *
     * @param testCase The test case generated by LLM.
     * @param xmlFileName The XML file name to read data from.
     */
    private fun saveData(testCase: TestCaseGeneratedByLLM, xmlFileName: String) {
        indicator.text = TestSparkBundle.message("testCasesSaving")
        val setOfLines = mutableSetOf<Int>()
        var isCorrectSourceFile: Boolean
        File(xmlFileName).readText().konsumeXml().apply {
            children("report") {
                children("sessioninfo") {}
                children("package") {
                    children("class") {
                        children("method") {
                            children("counter") {}
                        }
                        children("counter") {}
                    }
                    children("sourcefile") {
                        isCorrectSourceFile = this.attributes.getValue("name") == fileNameFQN
                        children("line") {
                            if (isCorrectSourceFile && this.attributes.getValue("mi") == "0") {
                                setOfLines.add(this.attributes.getValue("nr").toInt())
                            }
                        }
                        children("counter") {}
                    }
                    children("counter") {}
                }
                children("counter") {}
            }
        }

        log.info("Test case saved:\n$testCase")

        // Add lines that Jacoco might have missed because of its limitation during the exception
        setOfLines.addAll(linesCoveredDuringTheException[testCase.name]!!)

        report.testCaseList[testCase.name] = TestCase(
            testCase.name,
            testCase.toString(),
            setOfLines,
            setOf(),
            setOf(),
        )
    }

    /**
     * Executes a command line process and returns the output as a string.
     *
     * @param cmd The command line arguments as an ArrayList of strings.
     * @return The output of the command line process as a string.
     */
    private fun runCommandLine(cmd: ArrayList<String>): String {
        val compilationProcess = GeneralCommandLine(cmd)
        return ScriptRunnerUtil.getProcessOutput(compilationProcess, ScriptRunnerUtil.STDERR_OUTPUT_KEY_FILTER, 30000)
    }

    /**
     * Generates the path for the command by concatenating the necessary paths.
     *
     * @param buildPath The path of the build file.
     * @return The generated path as a string.
     */
    private fun getPath(buildPath: String): String {
        // create the path for the command
        val pluginsPath = System.getProperty("idea.plugins.path")
        val junitPath = "$pluginsPath${sep}TestSpark${sep}lib${sep}junit-4.13.jar"
        val mockitoPath = "$pluginsPath${sep}TestSpark${sep}lib${sep}mockito-core-5.0.0.jar"
        val hamcrestPath = "$pluginsPath${sep}TestSpark${sep}lib${sep}hamcrest-core-1.3.jar"
        return "$junitPath:$hamcrestPath:$mockitoPath:$buildPath"
    }

    /**
     * Retrieves the absolute path of the specified library.
     *
     * @param libraryName the name of the library
     * @return the absolute path of the library
     */
    private fun getLibrary(libraryName: String): String {
        val pluginsPath = System.getProperty("idea.plugins.path")
        return "$pluginsPath${sep}TestSpark${sep}lib${sep}$libraryName"
    }
}
